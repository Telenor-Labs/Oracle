# Copyright 2020 (C), Oracle and/or its affiliates. All rights reserved.  

#########################################################
#            Section Start: global attributes           #   
#########################################################
global:
  # MYSQL configurable params
  mysql:
    primary:
      # Primary DB Connection Service IP or Hostname
      host: &mySqlHostRef "mysql-nrf-svc.oracle-defence-nrf"
      port: &mySqlPortRef 3306
    secondary:
      # Secondary DB Connection Service IP or Hostname
      host: ""
      port: ""

  # This flag shall be set to true if Discovered SLF Candidate feature is enabled.
  enableNrfArtisanService: false

  # Engineering configuration to select database (read only)
  databaseEngine: &databaseEngine "InnoDB"

  #@Engineering-start

  ingressCommonSvcName: &ingressCommonSvcName igw
  egressCommonSvcName: &egressCommonSvcName egw
  appinfoCommonSvcName: &appinfoCommonSvcName appinfo
  altRouteCommonSvcName: &altRouteCommonSvcName altRoute


  # Engineering configuration: To enable system level logs
  systemLoggingLevel: "WARN"
  #@Engineering-end

  # Below attributes dbMonitorSvcHost, dbMonitorSvcPort and replicationStatusResourceUri
  # are mandatory to be configured before enabling the Geo-Redundancy Feature. They are set to default/sample values
  # and needs to be updated.
  #
  # Value for these attributes can be checked by services of DB-tier for db monitor svc.
  #
  # These values can be updated later using Rest APIs for geoRedundancyOptions with attribute replicationStatusUri
  #
  #Host name of db monitor service
  dbMonitorSvcHost: "mysql-cluster-db-monitor-svc"
  #Port of db monitor service
  dbMonitorSvcPort: 8080
  #Resource uri used to retrieve replication channel status details (read only)
  replicationStatusResourceUri: "db-tier/status/replication"


  # OCNRF's NF Instance ID is a mandatory parameter
  #
  # This is the NfInstanceId of OCNRF that will get deployed.
  # Format of NfInstanceId:
  # Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122
  #
  # e.g.: 6faf1bbc-6e4a-4454-a507-a14ef8e1bc5c
  #
  # This ID is used to uniquely identify this OCNRF instance in a Geo-Redundant Deployment.
  # Hence it is very important that the Instance ID MUST be unique across all OCNRF deployments.
  #
  nrfInstanceId: &nrfInstanceId "76260676-1db1-45b1-b88e-5e2b28762e1f"




  #
  # siteNameToNrfInstanceIdMapping is a list attribute signifies the mapping between the remote sites'
  # nrfInstanceId and corresponding database siteName
  #
  # This configuration consumed ONLY when Geo-Redundancy feature is ENABLED.
  # CAUTION:- Any wrong configuration can lead to Geo-Redundancy feature failure.
  #
  # This attribute can be updated later using Rest APIs for geoRedundancyOptions with
  # attribute siteNameToNrfInstanceIdMapping
  #
  siteNameToNrfInstanceIdMapping:
  #- siteName: 5faf1bbc-6e4a-4454-a507-a14ef8e1bc5c
  #  nrfInstanceId: 723da493-528f-4bed-871a-2376295c0020

  # Docker Registry's Host or IP from where container images will be pulled.
  dockerRegistry: hubcluster-registry-quay-quay-enterprise.apps.mgmt.next.lab/oracle/ocnrf

  #@Engineering-start
  # Engineering configuration: Required for CNC Data Collector
  vendor: "Oracle"
  app_name: "ocnrf"

  # Engineering configuration: Maximum time to wait for response
  readTimeout: 10
  #@Engineering-end
  # Namespace and secret name for database connections
  # This secret will contain mysql db name, user to access db name and password for the user
  database:
    # Namespace where the Secret is created
    nameSpace: "oracle-defence-nrf"
    # K8s Secret containing Database/user/password for services
    appUserSecretName: "appuser-secret"
    # K8s Secret containing Database/user/password for DB Hooks for creating tables
    privilegedUserSecretName: &privilegedSecretNameRef "privilegeduser-secret"
    commonConfigDbName: &dbNameRef 'commonConfigurationDB'
    #@Engineering-start
    dbUNameLiteral: &dbUserRef dbUsername
    dbPwdLiteral: &dbPwdRef dbPassword
    #@Engineering-end

  #Mandatory: This parameter must be set to "true" when NRF is deployed with the Service Mesh

  serviceMeshCheck: false
  # Mandatrory: needs to be set with correct url format http://127.0.0.1:<istio management port>/quitquitquit" if NRF is deployed with the Service Mesh.
  istioSidecarQuitUrl: "http://127.0.0.1:15000/quitquitquit"
  # Mandatrory: needs to be set with correct url format http://127.0.0.1:<istio management port>/ready" if NRF is deployed with the Service Mesh.
  istioSidecarReadyUrl: "http://127.0.0.1:15000/ready"

  #@Engineering-start
  #Upgrade strategy, maxUnavailable pods declared for upgrade process
  #The only supported upgrade strategy is RollingUpdate
  upgradeStrategy: "RollingUpdate"
  maxUnavailable: "25%"
  #@Engineering-end

  # Resources allocated for execution of jobs associated with hooks
  hookJobResources:
    limits:
      #@min_resources- cpu: 1
      cpu: 2
      #@min_resources- memory: 1Gi
      memory: 2Gi
    requests:
      #@min_resources- cpu: 1
      cpu: 1
      #@min_resources- memory: 1Gi
      memory: 1Gi

  #@Engineering-start
  # Engineering configuration: This value should not be changed
  hookWeight:
    nrfConfiguration: "0"
    nfRegistration: "1"
    nfSubscription: "2"
    nrfAuditor: "3"
    nfDiscovery: "3"
    nfAccessToken: "3"
    nrfArtisan: "3"
  #@Engineering-end

  #This attribute shall be set to true for the below conditions
  #1. DNS SRV resolution of SCP is required for SLF queries
  alternateRouteServiceEnable: false

  # ********  Sub-Section Start: Day Zero Configuration  ********
  #*******************************************************************
  # post install configuration parameters:
  dayZeroConfiguration:
    hplmnList:
    - mcc: "242"
      mnc: "01"
    - mcc: "242"
      mnc: "12"
    ocnrfHost: ocnrf-ingressgateway.oracle-defence-nrf
    ocnrfPort: 80
    ocnrfScheme: http
    #@Engineering-start
    #Engineering configuration: This value should not be changed
    # No. of retries & ResourceUri of  configuration microservice for post install configuration
    maxRetries: 15
    #Wait time for the configuration post-install hook
    waitTime: 30000
    generalOptionsResourceUri: /nrf-configuration/v1/generalOptions
    accessTokenOptionsResourceUri: /nrf-configuration/v1/nfAccessTokenOptions
    #@Engineering-end
  # ********  Sub-Section End: Day Zero Configuration  ********
  #*******************************************************************

  #@Engineering-start
  # ********  Sub-Section Start: APP-INFO Global Parameters ********
  #*******************************************************************

  appinfoServiceEnable: true
  appinfoCheckEnabled: true
  nfName: ocnrf

  # ********  Sub-Section End: APP-INFO Global Parameters ********
  #*******************************************************************
  #@Engineering-end


  #@Engineering-start
  # ********  Sub-Section Start: NRF-Client Global Parameters ********
  #*******************************************************************
  #
  # Engineering configuration: Microservice level control if specific microservice need to be disabled
  nrfClientEnable: true
  # Engineering configuration: Jaeger-agent host
  envJaegerAgentHost: ''
  # Engineering configuration: Jaeger-agent port
  envJaegerAgentPort: 6831
  nrfClientNodePort: 0
  configServerEnable: true

  # Engineering configuration: MYSQL HOST IP, this is used by config-server
  #envMysqlHost: ocnrf-mysql
  # Engineering configuration: MYSQL HOST USER
  envMysqlUser: nrfclient
  # Engineering configuration: MYSQL HOST PASSWORD
  envMysqlPassword: nrfclient
  # Engineering configuration: MYSQL HOST PORT
  #envMysqlPort: '3306'
  # Engineering configuration: MYSQL CONFIG-SERVER Database name
  envMysqlDatabase: ocpm_config_server
  # Engineering configuration: Readiness-Detector image details with tag
  imageServiceDetector: nrf-client/readiness-detector:latest

  # ********  Sub-Section End: NRF-Client Global Parameters ********
  #*******************************************************************
  #@Engineering-end

  # CNCConsole integration flag
  #
  # if cncConsoleDeployed is false, then nrfConfiguration micro-service must
  # be deployed with service type as LoadBalancer (type: LoadBalancer)
  # Otherwise nrfConfiguration micro-service should be deployed with service
  # type as ClusterIP (type: ClusterIP)
  cncConsoleDeployed: false

  # serviceAccountName is a mandatory parameter
  #
  # Kubernetes Secret resource is used for below use cases in OCNRF
  # - For providing MYSQL DB Details to micro-services
  # - For providing NRF's Private Key, NRF's Certificate and CA Certificate Details to Ingress/Egress Gateway for TLS
  # - For providing NRF's Private and NRF's Public Keys to nfAccessToken micro-service for Digitally Signing AccessTokenClaims.
  # - For providing Producer/Consumer NF's Service/Endpoint details for routing messages from/to Egress/Ingress Gateway.
  #
  # The Secret(s) can be under same namespace where OCNRF is getting deployed (recommended) or
  # Operator can choose to use different namespaces for different secret(s).
  #
  # If all the Secret(s) are under same namespace as OCNRF, then Kubernetes Role can be binded with the given ServiceAccount.
  # Otherwise ClusterRole needs to be binded with the given ServiceAccount.
  #
  # The Role/ClusterRole needs to be created with resources: (services, configmaps, pods, secrets, endpoints)  and (verbs: get, watch, list)
  #
  # E.g:
  #
  #     apiVersion: rbac.authorization.k8s.io/v1
  #     kind: Role
  #     metadata:
  #       labels:
  #       name:  ocnrf-role
  #       namespace: ocnrf
  #     rules:
  #       - apiGroups:
  #           - ""
  #         resources:
  #           - services
  #           - configmaps
  #           - pods
  #           - secrets
  #           - endpoints
  #         verbs:
  #           - get
  #           - list
  #           - watch
  serviceAccountName: "ocnrf-serviceaccount"

  #@Engineering-start
  # Engineering configuration
  # Prometheus Scraping Configuration
  prometheusScrapingConfig:
    enabled: true
    path: "/actuator/prometheus"

  #@Engineering-end

  #@Engineering-start
  # Engineering configuration
  overrideReplicationCheck: ""

  #@Engineering-end


  # ********  Sub-Section Start: Ingress Gateway Global Parameters   ********
  #**************************************************************************


  # If Static load balancer IP needs to be set, then set staticIpAddressEnabled flag to true and provide value for staticIpAddress
  # Else random IP will be assigned by the External LoadBalancer from its IP Pool
  staticIpAddressEnabled: false
  staticIpAddress: 10.75.212.50

  # If Static node port needs to be set, then set staticNodePortEnabled flag to true and
  # provide value for staticHttpNodePort or staticHttpsNodePort
  # Else random node port will be assigned by K8
  staticNodePortEnabled: false
  staticHttpNodePort: 30080
  staticHttpsNodePort: 30443

  enableIncomingHttp: &enableIncomingHttp true
  enableIncomingHttps: &enableIncomingHttps false

  # Service Port on which OCNRF's Ingress Gateway will be exposed
  # If enableIncomingHttp is true, publicHttpSignalingPort will be used as HTTP/2.0 Port (unsecured)
  # If enableIncomingHttps is true, publicHttpsSignallingPort Port will be used as HTTPS/2.0 Port (secured TLS)
  publicHttpSignalingPort: 80
  publicHttpsSignallingPort: 443

  #Configuration related to XFCC header validation/extraction
  xfccHeaderValidation:
    validation:
      nfList:
        - nf1.com
      #@Engineering-start
      # Engineering configuration
      # exceptionType can take any of the valid values mentioned below. These values are the trigger cause of the error scenarios during xfcc validation
      # XFCC_HEADER_NOT_PRESENT_OR_EMPTY,
      #	XFCC_MATCHCERTCOUNT_GREATER_THAN_CERTS_IN_HEADER,
      #	XFCC_HEADER_INVALID
      errorTrigger:
        - exceptionType: XFCC_HEADER_NOT_PRESENT_OR_EMPTY
          errorCode: "401"
          errorDescription: "xfcc header is not present or empty in the request at ingressgateway"
          errorCause: "UNSPECIFIED_MSG_FAILURE"
          errorTitle: "XFCC_HEADER_NOT_PRESENT_OR_EMPTY"
          retryAfter: ""
          redirectUrl: ""
        - exceptionType: XFCC_MATCHCERTCOUNT_GREATER_THAN_CERTS_IN_HEADER
          errorCode: "403"
          errorDescription: "matchCerts count is greater than the certs in the request at ingressgateway"
          errorCause: "UNSPECIFIED_MSG_FAILURE"
          errorTitle: "XFCC_MATCHCERTCOUNT_GREATER_THAN_CERTS_IN_HEADER"
          retryAfter: ""
          redirectUrl: ""
        - exceptionType: XFCC_HEADER_INVALID
          errorCode: "403"
          errorDescription: "xfcc header is invalid at ingressgateway"
          errorCause: "UNSPECIFIED_MSG_FAILURE"
          errorTitle: "XFCC_HEADER_INVALID"
          retryAfter: ""
          redirectUrl: ""
      #@Engineering-end
    extract:
      enabled: false
      #0//right most,-1//left most, 2-3rd from right most
      certExtractIndex: 0
      extractField: DNS
      #0//right most,-1//left most, 2-3rd from right most
      extractIndex: -1

  # ********  Sub-Section End: Ingress Gateway Global Parameters   ********
  #**************************************************************************


  # ********  Sub-Section Start: Custom Extension Global Parameters ********
  #**************************************************************************

  customExtension:
    allResources:
      labels: {}
      annotations: {}

    lbServices:
      labels: {}
      annotations: {}

    lbDeployments:
      labels: {}
      annotations: {}

    nonlbServices:
      labels: {}
      annotations: {}

    nonlbDeployments:
      labels: {}
      annotations: {}

  # ********  Sub-Section End: Custiom Extensions Global Parameters ********
  #**************************************************************************


  # ********  Sub-Section Start: Prefix/Suffix Global Parameters ************
  #**************************************************************************

  k8sResource:
    container:
      prefix:
      suffix:

  # ********  Sub-Section End: Prefix/Suffix Global Parameters *************
  #**************************************************************************

  #@Engineering-start
  # ********  Sub-Section Start: Nfregistration  Global Parameters   ********
  #**************************************************************************
  # Engineering configuration
  nfregistration:
    portConfiguration:
      # Port exposed by the service
      servicePort : 8080
      #container port
      containerPort: 8081
      #common service port
      commonServicePort: 9090

  # ********  Sub-Section End: Nfregistration  Global Parameters   ********
  #**************************************************************************

  # ********  Sub-Section Start: Nfsubscription  Global Parameters   ********
  #**************************************************************************
  # Engineering configuration
  nfsubscription:
    portConfiguration:
      # Port exposed by the service
      servicePort : 8080
      #container port
      containerPort: 8081
      #common service port
      commonServicePort: 9090

  # ********  Sub-Section End: Nfsubscription  Global Parameters   ********
  #**************************************************************************

  # ********  Sub-Section Start: Nrfauditor  Global Parameters   ********
  #**************************************************************************
  # Engineering configuration
  nrfauditor:
    portConfiguration:
      # Port exposed by the service
      servicePort : 8080
      #container port
      containerPort: 8081
      #common service port
      commonServicePort: 9090

  # ********  Sub-Section End: Nrfauditor  Global Parameters   ********
  #**************************************************************************

  # ********  Sub-Section Start: Nfdiscovery  Global Parameters   ********
  #**************************************************************************
  # Engineering configuration
  nfdiscovery:
    portConfiguration:
      # Port exposed by the service
      servicePort : 8080
      #container port
      containerPort: 8081
      #common service port
      commonServicePort: 9090

  # ********  Sub-Section End: Nfdiscovery  Global Parameters   ********
  #**************************************************************************

  # ********  Sub-Section Start: Nrfconfiguration  Global Parameters   ********
  #**************************************************************************
  # Engineering configuration
  nrfconfiguration:
    portConfiguration:
      # Port exposed by the service
      servicePort : &configurationServicePort 8080
      #container port
      containerPort: 8081
      #common service port
      commonServicePort: 9090

  # ********  Sub-Section End: Nrfconfiguration  Global Parameters   ********
  #**************************************************************************

  # ********  Sub-Section Start: Nfaccesstoken  Global Parameters   ********
  #**************************************************************************
  # Engineering configuration
  nfaccesstoken:
    portConfiguration:
      # Port exposed by the service
      servicePort : 8080
      #container port
      containerPort: 8081
      #common service port
      commonServicePort: 9090

  # ********  Sub-Section End: Nfaccesstoken  Global Parameters   ********
  #**************************************************************************

  # ********  Sub-Section Start: NrfArtisan  Global Parameters   ********
  #**************************************************************************
  # Engineering configuration
  nrfartisan:
    portConfiguration:
      # Port exposed by the service
      servicePort : 8080
      #container port
      containerPort: 8081
      #common service port
      commonServicePort: 9090

  # ********  Sub-Section End: NrfArtisan  Global Parameters   ********
  #**************************************************************************


  # ********  Sub-Section Start: appinfo Global Parameters   ********
  #**************************************************************************
  # Engineering configuration
  servicePorts:
    appInfoHttp: 5906
  containerPorts:
    monitoringHttp: 9000
    appInfoHttp: 5906
  # ********  Sub-Section End: appinfo Global Parameters   ********
  #**************************************************************************

  # ********  Sub-Section Start: EGRESS-GATEWAY Global Parameters ********
  # **********************************************************************
  # Engineering configuration
  egressGateway:
    port: 8080
    sslPort: 8442
  # ********  Sub-Section End: EGRESS-GATEWAY Global Parameters **********
  # **********************************************************************
  #@Engineering-end

  # ********  Sub-Section Start: Helm Test Global Parameters   ********
  #**************************************************************************
  # Helm test hook related configurations
  test:
    nfName: ocnrf
    image:
      name: helm-test
      tag: 22.1.1
      pullPolicy: IfNotPresent
    config:
      logLevel: WARN
      timeout: 240      #Beyond this duration in seconds helm test will be considered as failure

  # ********  Sub-Section End: Helm Test Global Parameters   ********
  #**************************************************************************


  # ********  Sub-Section Start: Debug Tool Container Global Parameters   ********
  #*******************************************************************************

  # Allowed Values: DISABLED, ENABLED
  extraContainers: DISABLED
  extraContainersTpl: |
    - command:
        - /bin/sleep
        - infinity
      image: {{ printf "%s/%s:%s" (include "getdockerregistry.name" .) "ocdebug-tools" "22.1.0" }}
      imagePullPolicy: IfNotPresent
      name: {{ printf "%s-tools-%s" (include "getprefix" .) (include "getsuffix" .) | trunc 63 | trimPrefix "-" | trimSuffix "-"  }}
      resources:
        requests:
          ephemeral-storage: "2Gi"
          cpu: "0.5"
          memory: "1Gi"
        limits:
          ephemeral-storage: "4Gi"
          cpu: "1"
          memory: "2Gi"
      securityContext:
        allowPrivilegeEscalation: true
        capabilities:
          drop:
          - ALL
          add:
          - NET_RAW
          - NET_ADMIN
        readOnlyRootFilesystem: false
        runAsUser: 7000

  # ********  Sub-Section End: Debug Tool Container Global Parameters   ********
  #*******************************************************************************


#########################################################
#            Section End  : global attributes           #
#########################################################


#########################################################
#            Section Start: ingressgateway attributes   #
#########################################################
ingress-gateway:
  global:
    # Service Type
    type: LoadBalancer

    # For Ephemeral Storage (Values specified are in MB)
    logStorage: 70
    crictlStorage: 1
    ephemeralStorageLimit: 1024

    #@Engineering-start
    # Engineering configuration
    #CONFIGUREABLE ERROR CODES
    configurableErrorCodes:
      enabled: true
      errorScenarios:
        - exceptionType: "ConnectionTimeout"
          errorCode: "408"
          errorDescription: "Connection timeout at ingressgateway"
          errorCause: "UNSPECIFIED_NF_FAILURE"
          errorTitle: "ConnectionTimeout"
        - exceptionType: "RequestTimeout"
          errorCode: "408"
          errorDescription: "Request Timeout at ingressgateway"
          errorCause: "UNSPECIFIED_NF_FAILURE"
          errorTitle: "RequestTimeout"
        - exceptionType: "UnknownHostException"
          errorCode: "500"
          errorDescription: "Unknown Host at ingressgateway"
          errorCause: "UNSPECIFIED_NF_FAILURE"
          errorTitle: "UnknownHostException"
        - exceptionType: "ConnectException"
          errorCode: "503"
          errorDescription: "Connection failure at ingressgateway"
          errorCause: "UNSPECIFIED_NF_FAILURE"
          errorTitle: "ConnectException"
        - exceptionType: "RejectedExecutionException"
          errorCode: "503"
          errorDescription: "Rejected Execution at ingressgateway"
          errorCause: "UNSPECIFIED_NF_FAILURE"
          errorTitle: "RejectedExecutionException"
        - exceptionType: "BlackListIpException"
          errorCode: "401"
          errorDescription: "Black listed IP at ingressgateway"
          errorCause: "UNSPECIFIED_MSG_FAILURE"
          errorTitle: "BlackListIpException"
        - exceptionType: "ClosedChannelException"
          errorCode: "503"
          errorDescription: "Closed channel at ingressgateway"
          errorCause: "UNSPECIFIED_NF_FAILURE"
          errorTitle: "ClosedChannelException"
        - exceptionType: "NotFoundException"
          errorCode: "404"
          errorDescription: "Not Found at ingressgateway"
          errorCause: "UNSPECIFIED_MSG_FAILURE"
          errorTitle: "NotFoundException"
        - exceptionType: "InternalError"
          errorCode: "500"
          errorDescription: "Internal Processing error at ingressgateway"
          errorCause: "UNSPECIFIED_MSG_FAILURE"
          errorTitle: "InternalError"
        - exceptionType: "LateArrivalException"
          errorCode: "504"
          errorDescription: "Request has already expired at ingressgateway"
          errorCause: "TIMED_OUT_REQUEST"
          errorTitle: "LateArrivalException"
          retryAfter: ""
          redirectUrl: ""
    #@Engineering-end

  #@Engineering-start
  # Engineering configuration
  gracefulShutdown:
    # Grace period to wait for active requests to be executed
    # If there are no active requests then this period is neglected
    gracePeriod: 1m # 's' in case of seconds and 'm' in case of minutes
    # Configurable error code to be sent when new requests are sent during shutdown phase
    defaultErrorCode: 500
    errorDescription: ""
    errorCause: "UNSPECIFIED_NF_FAILURE"
    errorTitle: ""
    retryAfter: ""
    redirectUrl: ""
      #@Engineering-end

  # This flag is for enabling/disabling HTTP/2.0  (insecure) in Ingress Gateway.
  # If the value is set to false, NRF will not accept any HTTP/2.0 (insecure) Traffic
  # If the value is set to true, NRF will accept HTTP/2.0 (insecure) Traffic
  enableIncomingHttp: *enableIncomingHttp

  # This flag is for enabling/disabling HTTPS/2.0  (secured TLS) in Ingress Gateway.
  # If the value is set to false, NRF will not accept any HTTPS/2.0 (secured) Traffic
  # If the value is set to true, NRF will accept HTTPS/2.0 (secured) Traffic
  enableIncomingHttps: *enableIncomingHttps

  # Set below flag to true when deployed in Ipv6 enabled setup
  isIpv6Enabled: false

  #@Engineering-start
  # Engineering configuration
  # This flag is for enabling/disabling HTTPS/2.0  (secured TLS) in Ingress Gateway towards Microservices.
  enableOutgoingHttps: false

  # Engineering configuration
  nameOverride: ingressgateway
  #@Engineering-end

  # Ingress Gateway Service Container Image Details
  image:
    # Ingress Gateway image name
    name: ocingress_gateway
    # tag name of image
    tag: 22.1.4
    # Pull Policy - Possible Values are:- Always, IfNotPresent, Never
    pullPolicy: IfNotPresent

  # Ingress Gateway Init  Container Image Details
  initContainersImage:
    # init Containers image name
    name: configurationinit
    # tag name of init Container image
    tag: 22.1.2
    # Pull Policy - Possible Values are:- Always, IfNotPresent, Never
    pullPolicy: IfNotPresent


  # Ingress Gateway Update Container Image Details
  updateContainersImage:
    # update Containers image name
    name: configurationupdate
    # tag name of update Container image
    tag: 22.1.2
    # Pull Policy - Possible Values are:- Always, IfNotPresent, Never
    pullPolicy: IfNotPresent

  # Common Config hook
  dbHookImage:
    # image name
    name: common_config_hook
    # tag 
    tag: 22.1.2
    # Pull Policy - Possible Values are:- Always, IfNotPresent, Never
    pullPolicy: IfNotPresent

  #@Engineering-start
  # Engineering configuration
  ports:
    actuatorPort: 9090
    containerPort: 8081
    containersslPort: 8443
  #@Engineering-end

  # enable Jaeger tracing
  jaegerTracingEnabled: true
  openTracing :
    jaeger:
      udpSender:
        # Update this configuration when jaeger tracing is enabled.
        # udpsender host
        host: "jaeger-agent.cne-infra"
        # udpsender port
        port: 6831
      # Jaeger message sampler. Value range: 0 to 1
      # e.g. Value 0: No Trace will be sent to Jaeger collector
      # e.g. Value 0.3: 30% of message will be sampled and will be sent to Jaeger collector
      # e.g. Value 1: 100% of message (i.e. all the messages) will be sampled and will be sent to Jaeger collector
      probabilisticSampler: 1

  # Allowed CipherSuites for TLS1.2
  cipherSuites:
    - TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
    - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
    - TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
    - TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
    - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
    - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256

  service:
    # configuration under ssl section is mandatory if enableIncomingHttps is configured as "true"
    ssl:
      #@Engineering-start
      # Engineering configuration: Supported TLS Version
      tlsVersion: TLSv1.2
      #@Engineering-end

      # OCNRF private key details for HTTPS
      # Secret Name, Namespace, Keydetails
      privateKey:
        k8SecretName: ocingress-secret
        k8NameSpace: ocnrf
        rsa:
          fileName: rsa_private_key_pkcs1.pem
        ecdsa:
          fileName: ssl_ecdsa_private_key.pem

      # OCNRF certificate details for HTTPS
      # Secret Name, Namespace, Keydetails
      certificate:
        k8SecretName: ocingress-secret
        k8NameSpace: ocnrf
        rsa:
          fileName: ssl_rsa_certificate.crt
        ecdsa:
          fileName: ssl_ecdsa_certificate.crt

      # OCNRF CA details for HTTPS
      caBundle:
        k8SecretName: ocingress-secret
        k8NameSpace: ocnrf
        fileName: caroot.cer

      # OCNRF KeyStore password for HTTPS
      # Secret Name, Namespace, Keydetails
      keyStorePassword:
        k8SecretName: ocingress-secret
        k8NameSpace: ocnrf
        fileName: ssl_keystore.txt

      # OCNRF TrustStore password for HTTPS
      # Secret Name, Namespace, Keydetails
      trustStorePassword:
        k8SecretName: ocingress-secret
        k8NameSpace: ocnrf
        fileName: ssl_truststore.txt

      # Initial Algorithm for HTTPS
      # Supported Values: ES256, RS256
      initialAlgorithm: ES256

    # Labels and Annotations that are specific to service ingressgateway are added here.
    customExtension:
      labels: {}
      annotations:
        oracle.com.cnc/app-protocols: '{"http2-tcp":"HTTP2","http2-tls":"HTTP2"}'

  # Labels and Annotations that are specific to deployment ingressgateway are added here.
  deployment:
    customExtension:
      labels: {}
      annotations: {}

  #@Engineering-start
  # Engineering configuration: OAUTH CONFIGURATION
  oauthValidatorEnabled: false
  nfType: NRF
  nfInstanceId: 76260676-1db1-45b1-b88e-5e2b28762e1f
  producerScope: nnrf-nfm, nnrf-disc
  allowedClockSkewSeconds: 0
  nrfPublicKeyKubeSecret: ocingress-secret
  nrfPublicKeyKubeNamespace: ocnrf
  validationType: strict
  producerPlmnMNC: ''
  producerPlmnMCC: ''

  log:
    # setting logging level
    # Possible values - OFF, FATAL, ERROR, WARN, INFO, DEBUG, TRACE
    level:
      root: WARN
      ingress: WARN
      oauth: WARN
      updateContainer: WARN
      configclient: WARN
      hook: WARN
      cncc:
        security: WARN
    traceIdGenerationEnabled: true
  #@Engineering-end

  readinessProbe:
    # tells the kubelet that it should wait second before performing the first probe
    initialDelaySeconds: 30
    # Number of seconds after which the probe times out
    timeoutSeconds: 3
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 10
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 3

  livenessProbe:
    # tells the kubelet that it should wait second before performing the first probe
    initialDelaySeconds: 30
    # Number of seconds after which the probe times out
    timeoutSeconds: 3
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 15
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 3

  # Resource details
  resources:
    limits:
      #Container's cpu and memory
      #@min_resources- cpu: 1
      cpu: 6
      # Init-service cpu limit
      initServiceCpu: 1
      # Update-service cpu limit
      updateServiceCpu: 1
      # The Container's memory limit
      #@min_resources- memory: 1Gi
      memory: 4Gi
      # Init-service memory limit
      initServiceMemory: 1Gi
      # Update-service memory limit
      updateServiceMemory: 1Gi
    requests:
      # The Container's memory cpu
      #@min_resources- cpu: 1
      cpu: 6
      # Init-service cpu limit
      initServiceCpu: 1
      # Update-service cpu limit
      updateServiceCpu: 1
      # The Container's memory limit
      #@min_resources- memory: 1Gi
      memory: 4Gi
      # Init-service memory limit
      initServiceMemory: 1Gi
      # Update-service memory limit
      updateServiceMemory: 1Gi
    target:
      averageCpuUtil: 80

  # Min replicas to scale to maintain an average CPU utilization
  #@min_resources- minReplicas: 1
  minReplicas: 1
  # Max replicas to scale to maintain an average CPU utilization
  maxReplicas: 1

  #@Engineering-start
  # Engineering Configuration:  Micro-Service routes
  # NOTE: These Configurations must be updated whenever template service.fullname
  # or service http port is modified.
  routesConfig:
    - id: registration_mapping
      uri: http://{{ template "registration.service.fullname" . }}:{{ template "registration.service.port" . }}
      path: /nnrf-nfm/v1/nf-instances/**
      order: 1
    - id: subscription_mapping
      uri: http://{{ template "subscription.service.fullname" . }}:{{ template "subscription.service.port" . }}
      path: /nnrf-nfm/v1/subscriptions/**
      order: 2
    - id: disc_mapping
      uri: http://{{ template "discovery.service.fullname" . }}:{{ template "discovery.service.port" . }}
      path: /nnrf-disc/v1/nf-instances/**
      order: 3
    - id: accesstoken_mapping
      uri: http://{{ template "accesstoken.service.fullname" . }}:{{ template "accesstoken.service.port" . }}
      path: /oauth2/token
      order: 4

  # Engineering Configuration: Jetty Client settings
  maxRequestsQueuedPerDestination: 5000

  # Engineering Configuration: Below value will be used when serviceMeshCheck is enabled
  maxConnectionsPerDestination: 16
  maxConnectionsPerIp: 16
  #Jetty Client settings
  maxConcurrentPushedStreams: 5000
  connectionTimeout: 10000 #(ms)
  requestTimeout: 6000 #(ms)
  #@Engineering-end

  # Allowed Values: DISABLED, ENABLED, USE_GLOBAL_VALUE
  extraContainers: USE_GLOBAL_VALUE

  #@Engineering-start
  #To allow igw to redirect to uri present in location header in case of 301,308,302,303,307 response code
  #set autoRedirect to true otherwise set it to false. Default value is true
  autoRedirect: false
  # Engineering Configuration:  Micro-Service routes
  # Common configuration service
  commonCfgClient:
    # Flag to enable/ disable the feature
    enabled: true
  commonCfgServer:
    configServerSvcName: nrfconfiguration
    port: *configurationServicePort
    pollingInterval: 5000
  # Common service name that is currently expecting updates from server
  commonServiceName: *ingressCommonSvcName
  restoreBackupOnInstall: false
  #@Engineering-end
  #Db hook Configuration
  # Engineering configuration to select database (read only)
  dbConfig:
    dbHost: *mySqlHostRef
    dbPort: *mySqlPortRef
    secretName: *privilegedSecretNameRef
    dbName: *dbNameRef
    dbEngine: *databaseEngine
    #@Engineering-start
    # Name of the Key configured for "DB Username" in Secret with following name: "<dbConfig.secretName>"
    dbUNameLiteral: *dbUserRef
    # Name of the Key configured for "DB Password" in Secret with following name: "<dbConfig.secretName>"
    dbPwdLiteral: *dbPwdRef
    #@Engineering-end
  #@Engineering-start
  #Dns refresh interval customized to minimalize traffic loss during issu
  dnsRefreshDelay: 5000
  #@Engineering-end
  
#########################################################
#            Section End  : ingressgateway attributes   #
#########################################################


#########################################################
#            Section Start: egressgateway attributes   #
#########################################################
egress-gateway:
  global:
    #  For Ephemeral Storage (Values specified are in MB)
    logStorage: 70
    crictlStorage: 1
    ephemeralStorageLimit: 1024

  # This flag is for enabling/disabling HTTPS/2.0  (secured TLS) in Egress Gateway.
  # If the value is set to false, NRF will send only HTTP/2.0 (unsecured) Egress Traffic
  # If the value is set to true, NRF will send only HTTPS/2.0 (secured) Egress Traffic
  enableOutgoingHttps: false



  #@Engineering-start
  # Engineering Configuration:
  nameOverride: egressgateway

  serviceEgressGateway:
    actuatorPort: 9090
  #@Engineering-end

  # Egress Gateway Service Container Image Details
  deploymentEgressGateway:
    # Egress Gateway image name
    image: ocegress_gateway
    # tag name of image
    imageTag: 22.1.4
    # Pull Policy - Possible Values are:- Always, IfNotPresent, Never
    pullPolicy: IfNotPresent

  # Egress Gateway Init Container Image Details
  initContainersImage:
    # init Containers image name
    name: configurationinit
    # tag name of image
    tag: 22.1.2
    # Pull Policy - Possible Values are:- Always, IfNotPresent, Never
    pullPolicy: IfNotPresent


  # Egress Gateway Update Container Image Details
  updateContainersImage:
    # update Containers image name
    name: configurationupdate
    # tag name of image
    tag: 22.1.2
    # Pull Policy - Possible Values are:- Always, IfNotPresent, Never
    pullPolicy: IfNotPresent

  # Common Config hook
  dbHookImage:
    # image name
    name: common_config_hook
    # tag 
    tag: 22.1.2
    # Pull Policy - Possible Values are:- Always, IfNotPresent, Never
    pullPolicy: IfNotPresent

  # This flag needs to set it "true" if Service Mesh would be present where OCNRF will be deployed
  # This is to enable egress gateway to forward http2 (and not https) requests even when it receives http2 requests
  httpRuriOnly: "false"

  # enable Jaeger tracing
  jaegerTracingEnabled: true
  openTracing :
    jaeger:
      udpSender:
        # Update this configuration when jaeger tracing is enabled.
        # udpsender host
        host: "jaeger-agent.cne-infra"
        # udpsender port
        port: 6831
      # Jaeger message sampler. Value range: 0 to 1
      # e.g. Value 0: No Trace will be sent to Jaeger collector
      # e.g. Value 0.3: 30% of message will be sampled and will be sent to Jaeger collector
      # e.g. Value 1: 100% of message (i.e. all the messages) will be sampled and will be sent to Jaeger collector
      probabilisticSampler: 1
  oauthClient:
    enabled: true
    staticNrfList:
      - '{{ template "ingressgateway.service.fullname" . }}:{{ template "ingressgateway.service.port" . }}'
    nfType: NRF
    nfInstanceId: *nrfInstanceId

  #@Engineering-start
  # Engineering Configuration:
  consumerPlmnMNC: 11
  consumerPlmnMCC: 111
    #@Engineering-end

  #@Engineering-start
  # ********  Sub-Section Start: SCP released Parameters ********
  #*******************************************************************

  # Using SCP as an Proxy in Egress Gateway
  # If it is configured as false, SCP will not be used as an proxy.
  #   Messages will be directly sent to the Producers/HTTP Servers.
  # If it is configured as true, SCP will be used as an Proxy for
  #    delivering messages to the Producers/HTTP Servers.
  scp:
    # SCP Configuration For Egress Gateway
    # All the SCP related configuration will be used only
    # if scpIntegrationEnabled is set to true.
    scpIntegrationEnabled: false

    # SCP's default scheme  when 3gpp-sbi-target-apiroot header is missing
    scpDefaultScheme: https

    # Set this flag to true if re-routing to multiple SCP instances is to be enabled.
    scpRerouteEnabled: true

    # SCP's HTTP Host/IP and Port Combinations.
    # These will be while sending HTTP/2 and HTTPS/2 Egress traffic
    instances:
      scpSets:
        - setId: 0
          httpConfigs:
            - host: scp-host-1
              port: 101
              apiPrefix: "/"   # Change this value to corresponding prefix "/" is not expected to be provided along.
            - host: scp-host-2
              port: 102
              apiPrefix: "/"
          httpsConfigs:
            - host: scp-host-3
              port: 4431
              apiPrefix: "/"
            - host: scp-host-4
              port: 4434
              apiPrefix: "/"



  # ********  Sub-Section End : SCP released Parameters ********
  #*******************************************************************
  #@Engineering-end

  # Allowed CipherSuites for TLS1.2
  cipherSuites:
    - TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
    - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
    - TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
    - TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
    - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
    - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256

  service:
    # configuration under ssl section is mandatory if enableOutgoingHttps is configured as "true"
    ssl:
      #@Engineering-start
      # Engineering configuration: Support TLS Version.
      tlsVersion: TLSv1.2
      #@Engineering-end

      # OCNRF private key details for HTTPS
      # Secret Name, Namespace, Keydetails
      privateKey:
        k8SecretName: ocegress-secret
        k8NameSpace: ocnrf
        rsa:
          fileName: ssl_rsa_private_key.pem
        ecdsa:
          fileName: ssl_ecdsa_private_key.pem

      # OCNRF certificate details for HTTPS
      # Secret Name, Namespace, Keydetails
      certificate:
        k8SecretName: ocegress-secret
        k8NameSpace: ocnrf
        rsa:
          fileName: ssl_rsa_certificate.crt
        ecdsa:
          fileName: ssl_ecdsa_certificate.crt

      # OCNRF CA details for HTTPS
      caBundle:
        k8SecretName: ocegress-secret
        k8NameSpace: ocnrf
        fileName: ssl_cabundle.crt

      # OCNRF KeyStore password for HTTPS
      # Secret Name, Namespace, Keydetails
      keyStorePassword:
        k8SecretName: ocegress-secret
        k8NameSpace: ocnrf
        fileName: ssl_keystore.txt

      # OCNRF TrustStore password for HTTPS
      # Secret Name, Namespace, Keydetails
      trustStorePassword:
        k8SecretName: ocegress-secret
        k8NameSpace: ocnrf
        fileName: ssl_truststore.txt

      # Initial algorithm for HTTPS
      # Support Values: ES256, RS256
      initialAlgorithm: ES256

    # Service Type
    type: ClusterIP

    # Labels and Annotations that are specific to service egressgateway are added here.
    customExtension:
      labels: {}
      annotations: {}

    # Labels and Annotations that are specific to deployment egressgateway are added here.
  deployment:
    customExtension:
      labels: {}
      annotations: {}

  #@Engineering-start
  log:
    # setting logging level
    # Possible values - OFF, FATAL, ERROR, WARN, INFO, DEBUG, TRACE
    level:
      root: WARN
      egress: WARN
      oauth: WARN
      updateContainer: WARN
      configclient: WARN
      hook: WARN
  #@Engineering-end

  readinessProbe:
    # tells the kubelet that it should wait second before performing the first probe
    initialDelaySeconds: 30
    # Number of seconds after which the probe times out
    timeoutSeconds: 3
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 10
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 3

  livenessProbe:
    # tells the kubelet that it should wait second before performing the first probe
    initialDelaySeconds: 30
    # Number of seconds after which the probe times out
    timeoutSeconds: 3
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 15
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 3

  #@Engineering-start
  # Flag to configure default route in Egress Gateway. Configure this flag when sbiRoutingConfigMode and routeConfigMode are configured as REST
  configureDefaultRoute: true
  # Mode of operation for sbiRouting. Possible values are HELM, REST
  sbiRoutingConfigMode: REST
  # Mode of configuration for configuring routes. Possible values are HELM, REST
  routeConfigMode: REST
  #Note: routeConfigMode - REST and sbiRoutingConfigMode - HELM is not a valid configuration
  #@Engineering-end

  # Resource details
  resources:
    limits:
      #@min_resources- cpu: 1
      cpu: 6
      initServiceCpu: 1
      updateServiceCpu: 1
      #@min_resources- memory: 1Gi
      memory: 4Gi
      # Init-service memory limit
      initServiceMemory: 1Gi
      # Update-service memory limit
      updateServiceMemory: 1Gi
    requests:
      initServiceCpu: 1
      updateServiceCpu: 1
      # Init-service memory limit
      initServiceMemory: 1Gi
      # Update-service memory limit
      updateServiceMemory: 1Gi
      #@min_resources- cpu: 1
      cpu: 6
      #@min_resources- memory: 1Gi
      memory: 4Gi
    target:
      averageCpuUtil: 80

  # Min replicas to scale to maintain an average CPU utilization
  #@min_resources- minReplicas: 1
  minReplicas: 1
  # Max replicas to scale to maintain an average CPU utilization
  maxReplicas: 1

  #@Engineering-start
  # Engineering Configuration:
  requestTimeout: 3000 #(ms)
  #@Engineering-end

  # Allowed Values: DISABLED, ENABLED, USE_GLOBAL_VALUE
  extraContainers: USE_GLOBAL_VALUE


  #@Engineering-start
  #To allow igw to redirect to uri present in location header in case of 301,308,302,303,307 response code
  #set autoRedirect to true otherwise set it to false. Default value is true
  autoRedirect: false
  # Engineering Configuration:
  # Common configuration service
  commonCfgClient:
    # Flag to enable/ disable the feature
    enabled: true
  # Details of common configuration service for polling
  commonCfgServer:
    configServerSvcName: nrfconfiguration
    port: *configurationServicePort
    pollingInterval: 5000
  # Common service name that is currently expecting updates from server
  commonServiceName: *egressCommonSvcName
  restoreBackupOnInstall: false
  #@Engineering-end

  #Db hook Configuration
  # Engineering configuration to select database (read only)
  dbConfig:
    dbHost: *mySqlHostRef
    dbPort: *mySqlPortRef
    secretName: *privilegedSecretNameRef
    dbName: *dbNameRef
    dbEngine: *databaseEngine
    #@Engineering-start
    # Name of the Key configured for "DB Username" in Secret with following name: "<dbConfig.secretName>"
    dbUNameLiteral: *dbUserRef
    # Name of the Key configured for "DB Password" in Secret with following name: "<dbConfig.secretName>"
    dbPwdLiteral: *dbPwdRef
    #@Engineering-end



#########################################################
#            Section End  : egressgateway attributes   #
#########################################################


#########################################################
#            Section Start: nfregistration attributes   #
#########################################################
# NRF microservices
nfregistration:
  global:
    #  For Ephemeral Storage (Values specified are in MB)
    logStorage: 70
    crictlStorage: 1
    ephemeralStorageLimit: 1024

  #@Engineering-start
  enabled: true
  #@Engineering-end
  image:
    # image name
    name: ocnrf-nfregistration
    # tag name of image
    tag: 22.1.0
    # Pull Policy - Possible Values are:- Always, IfNotPresent, Never
    pullPolicy: IfNotPresent

  # Resource details
  resources:
    limits:
      #@min_resourcesresources- cpu: 1
      cpu: 4
      #@min_resources- memory: 1Gi
      memory: 2Gi
    requests:
      #@min_resources- cpu: 1
      cpu: 4
      #@min_resources- memory: 1Gi
      memory: 2Gi
    target:
      averageCpuUtil: 80

  # Min replicas to scale to maintain an average CPU utilization
  #@min_resources- minReplicas: 1
  minReplicas: 1
  # Max replicas to scale to maintain an average CPU utilization
  maxReplicas: 1

  hookRestartPolicy: Never
  #@Engineering-start
  # Engineering Configuration:
  podRestartPolicy: Always
  #@Engineering-end

  #@Engineering-start
  # Engineering Configuration:

  reg:
    # setting max-thread-pool-size
    maxThreadPoolSize: 25
    # setting core-thread-pool-size
    coreThreadPoolSize: 15
    # setting queue-capacity-size
    queueCapacitySize: 500
  # jaeger details
  jaeger:
    service:
      name: "occne-tracer-jaeger-collector.occne-infra"
      port: 9411
    #@Engineering-end



  readinessProbe:
    # tells the kubelet that it should wait xx second before performing the first probe
    initialDelaySeconds: 20
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 10
    # Number of seconds after which the probe times out
    timeoutSeconds: 3
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 3
  livenessProbe:
    # tells the kubelet that it should wait xx second before performing the first probe
    initialDelaySeconds: 20
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 10
    # Number of seconds after which the probe times out
    timeoutSeconds: 5
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 5

  #@Engineering-start
  # Engineering Configuration:
  server:
    # The maximum number of connections that the server will accept and process at any given time
    maxConnections: 10000
    # The maximum queue length for incoming connection requests
    queueSize: 100
    # maximum number of simultaneous requests that can be handled
    maxThreads: 200
    # The minimum number of threads always kept running
    spareThreads: 20
    # waiting time
    waitTime: 35

  # Engineering Configuration: publishing resource api
  nfInstancesApi: "nnrf-nfm/v1/nf-instances"

  # Engineering Configuration: The time interval between 2 consecutive system options fetch from DB in Milliseconds
  systemOptionsFetchInterval: 3000
  #@Engineering-end


  # enable/ disable server compression gzip
  responseCompressionGzip: true

  service:
    # Service Type
    type: ClusterIP

    # Labels and Annotations that are specific to service nfRegistration are added here.
    customExtension:
      labels: {}
      annotations: {}

  # Labels and Annotations that are specific to deployment nfRegistration are added here.
  deployment:
    customExtension:
      labels: {}
      annotations: {}


  #@Engineering-start
  # Engineering Configuration: setting hikari pool size
  # and Idle Timeout for DB Connections
  hikariPoolSize: 30
  hikariConnectionTimeout: 60000
  # hikariMinimumIdle should be less than maximum pool size
  hikariMinimumIdle: 10
  hikariIdleTimeout: 500000

  undertow:
    maxConcurrentStream: 100
    initialWindowSize: 65535
    noRequestTimeout: 60
    ioThreads: 8
    workerThreads: 64
    #@Engineering-end

  # Allowed Values: DISABLED, ENABLED, USE_GLOBAL_VALUE
  extraContainers: USE_GLOBAL_VALUE

#########################################################
#            Section End  : nfregistration attributes   #
#########################################################


#########################################################
#            Section Start: nfsubscription attributes   #
#########################################################
nfsubscription:
  global:
    #  For Ephemeral Storage (Values specified are in MB)
    logStorage: 70
    crictlStorage: 1
    ephemeralStorageLimit: 1024

  #@Engineering-start
  enabled: true
  #@Engineering-end
  image:
    # image name
    name: ocnrf-nfsubscription
    # tag name of image
    tag: 22.1.0
    # Pull Policy - Possible Values are:- Always, IfNotPresent, Never
    pullPolicy: IfNotPresent

  #@Engineering-start
  # Engineering Configuration:
  sub:
    # setting max-thread-pool-size
    maxThreadPoolSize: 25
    # setting core-thread-pool-size
    coreThreadPoolSize: 15
    # setting queue-capacity-size
    queueCapacitySize: 500
    svc:
      notificationMaxRetries: 1
  #@Engineering-end

  # Resource details
  resources:
    limits:
      #@min_resources- cpu: 1
      cpu: 4
      #@min_resources- memory: 1Gi
      memory: 2Gi
    requests:
      #@min_resources- cpu: 1
      cpu: 4
      #@min_resources- memory: 1Gi
      memory: 2Gi
    target:
      averageCpuUtil: 80

  # Min replicas to scale to maintain an average CPU utilization
  #@min_resources- minReplicas: 1
  minReplicas: 1
  # Max replicas to scale to maintain an average CPU utilization
  maxReplicas: 1

  hookRestartPolicy: Never
  #@Engineering-start
  # Engineering Configuration:
  podRestartPolicy: Always
  #@Engineering-end

  readinessProbe:
    # tells the kubelet that it should wait 25 second before performing the first probe
    initialDelaySeconds: 25
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 10
    # Number of seconds after which the probe times out
    timeoutSeconds: 3
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 3
  livenessProbe:
    # tells the kubelet that it should wait xx second before performing the first probe
    initialDelaySeconds: 25
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 10
    # Number of seconds after which the probe times out
    timeoutSeconds: 5
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 5

  #@Engineering-start
  # Engineering Configuration:
  server:
    # The maximum number of connections that the server will accept and process at any given time
    maxConnections: 10000
    # The maximum queue length for incoming connection requests
    queueSize: 100
    # maximum number of simultaneous requests that can be handled
    maxThreads: 200
    # The minimum number of threads always kept running
    spareThreads: 20
    # waiting time
    waitTime: 35

  # Engineering Configuration: The time interval between 2 consecutive system options fetch from DB in Milliseconds
  systemOptionsFetchInterval: 3000
  #@Engineering-end

  service:
    # Service Type
    type: ClusterIP

    # Labels and Annotations that are specific to service nfSubscription are added here.
    customExtension:
      labels: {}
      annotations: {}

  # Labels and Annotations that are specific to deployment nfSubscription are added here.
  deployment:
    customExtension:
      labels: {}
      annotations: {}

  #@Engineering-start
  # Engineering Configuration: setting hikari pool size
  # and Idle Timeout for DB Connections
  hikariPoolSize: 25
  hikariConnectionTimeout: 60000
  # hikariMinimumIdle should be less than maximum pool size
  hikariMinimumIdle: 10
  hikariIdleTimeout: 500000

  undertow:
    maxConcurrentStream: 100
    initialWindowSize: 65535
    noRequestTimeout: 60
    ioThreads: 8
    workerThreads: 64
  #@Engineering-end


  # Allowed Values: DISABLED, ENABLED, USE_GLOBAL_VALUE
  extraContainers: USE_GLOBAL_VALUE

#########################################################
#            Section End  : nfsubscription attributes   #
#########################################################


#########################################################
#            Section Start: nrfauditor attributes       #
#########################################################
nrfauditor:
  global:
    #  For Ephemeral Storage (Values specified are in MB)
    logStorage: 70
    crictlStorage: 1
    ephemeralStorageLimit: 1024

  #@Engineering-start
  enabled: true
  #@Engineering-end
  image:
    # image name
    name: ocnrf-nrfauditor
    # tag name of image
    tag: 22.1.0
    # Pull Policy - Possible Values are:- Always, IfNotPresent, Never
    pullPolicy: IfNotPresent


  hookRestartPolicy: Never
  #@Engineering-start
  # Engineering Configuration:
  podRestartPolicy: Always
  #@Engineering-end

  #@Engineering-start
  # Engineering Configuration:
  # Replicas - This is exact value without scaling
  replicaCount: 1

  # Engineering Configuration:
  audit:
    # setting subscription-audit-interval
    subInt: "10s"
    # setting heartbeat-audit-interval
    hbInt: "5s"
    # setting remote-heartbeat-audit-interval
    hbRemoteInt: "15s"
    # setting nf-profile-audit-interval
    nfInt: "10s"
    # setting audit wait-time
    waitTime: 35
    # subscription remote audit interval
    subRemoteInt: "75m"
    # setting nrf-event audit interval
    nrfEventInt: "60m"

    # setting max-thread-pool-size
    maxThreadPoolSize: 25
    # setting core-thread-pool-size
    coreThreadPoolSize: 15
    # setting queue-capacity-size
    queueCapacitySize: 500
    #@Engineering-end


  readinessProbe:
    # tells the kubelet that it should wait 25 second before performing the first probe
    initialDelaySeconds: 40
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 10
    # Number of seconds after which the probe times out
    timeoutSeconds: 3
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 3
  livenessProbe:
    # tells the kubelet that it should wait xx second before performing the first probe
    initialDelaySeconds: 40
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 10
    # Number of seconds after which the probe times out
    timeoutSeconds: 5
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 5

  # Resource details
  resources:
    limits:
      #@min_resources- cpu: 1
      cpu: 6
      #@min_resources- memory: 1Gi
      memory: 3Gi
    requests:
      #@min_resources- cpu: 1
      cpu: 6
      #@min_resources- memory: 1Gi
      memory: 3Gi


  service:
    # Service Type
    type: ClusterIP

    # Labels and Annotations that are specific to service nrfAuditor are added here.
    customExtension:
      labels: {}
      annotations: {}

  #Labels and Annotations that are specific to deployment nrfAuditor are added here.
  deployment:
    customExtension:
      labels: {}
      annotations: {}


  #@Engineering-start
  # Engineering Configuration: setting hikari pool size
  # and Idle Timeout for DB Connections
  hikariPoolSize: 30
  hikariConnectionTimeout: 60000
  # hikariMinimumIdle should be less than maximum pool size
  hikariMinimumIdle: 10
  hikariIdleTimeout: 500000
  #@Engineering-end

  # Allowed Values: DISABLED, ENABLED, USE_GLOBAL_VALUE
  extraContainers: USE_GLOBAL_VALUE

#########################################################
#            Section End  : nrfauditor attributes       #
#########################################################


#########################################################
#            Section Start: nfdiscovery attributes      #
#########################################################
nfdiscovery:
  global:
    #  For Ephemeral Storage (Values specified are in MB)
    logStorage: 70
    crictlStorage: 1
    ephemeralStorageLimit: 2048

  #@Engineering-start
  enabled: true
  #@Engineering-end
  image:
    # image name
    name: ocnrf-nfdiscovery
    # tag name of image
    tag: 22.1.0
    # Pull Policy - Possible Values are:- Always, IfNotPresent, Never
    pullPolicy: IfNotPresent

  # Resource details
  resources:
    limits:
      #@min_resources- cpu: 1
      cpu: 4
      #@min_resources- memory: 1Gi
      memory: 2Gi
    requests:
      #@min_resources- cpu: 1
      cpu: 4
      #@min_resources- memory: 1Gi
      memory: 2Gi
    target:
      averageCpuUtil: 80

  # Min replicas to scale to maintain an average CPU utilization
  #@min_resources- minReplicas: 1
  minReplicas: 1
  # Max replicas to scale to maintain an average CPU utilization
  maxReplicas: 1

  hookRestartPolicy: Never
  #@Engineering-start
  # Engineering Configuration:
  podRestartPolicy: Always
  #@Engineering-end

  readinessProbe:
    # tells the kubelet that it should wait xx second before performing the first probe
    initialDelaySeconds: 25
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 10
    # Number of seconds after which the probe times out
    timeoutSeconds: 3
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 3
  livenessProbe:
    # tells the kubelet that it should wait xx second before performing the first probe
    initialDelaySeconds: 25
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 10
    # Number of seconds after which the probe times out
    timeoutSeconds: 5
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 5

  #@Engineering-start
  # Engineering Configuration:
  disc:
    # setting max-thread-pool-size
    maxThreadPoolSize: 15

  server:
    # The maximum number of connections that the server will accept and process at any given time
    maxConnections: 10000
    # The maximum queue length for incoming connection requests
    queueSize: 100
    # maximum number of simultaneous requests that can be handled
    maxThreads: 200
    # The minimum number of threads always kept running
    spareThreads: 20
    # waiting time
    waitTime: 35

  # Engineering Configuration: The time interval between 2 consecutive system options fetch from DB in Milliseconds
  systemOptionsFetchInterval: 3000

  #@Engineering-end

  service:
    # Service Type
    type: ClusterIP

    # Labels and Annotations that are specific to service nfDiscovery are added here.
    customExtension:
      labels: {}
      annotations: {}

  #Labels and Annotations that are specific to deployment nfDiscovery are added here.
  deployment:
    customExtension:
      labels: {}
      annotations: {}

  #@Engineering-start
  # Engineering Configuration: setting hikari pool size
  # and Idle Timeout for DB Connections
  hikariPoolSize: 30
  hikariConnectionTimeout: 60000
  # hikariMinimumIdle should be less than maximum pool size
  hikariMinimumIdle: 10
  hikariIdleTimeout: 500000

  undertow:
    maxConcurrentStream: 100
    initialWindowSize: 65535
    noRequestTimeout: 60
    ioThreads: 8
    workerThreads: 64
  #@Engineering-end

  # Allowed Values: DISABLED, ENABLED, USE_GLOBAL_VALUE
  extraContainers: USE_GLOBAL_VALUE

#########################################################
#            Section End  : nfdiscovery attributes      #
#########################################################

#########################################################
#            Section Start: nfaccesstoken attributes    #
#########################################################
# Details of NF Access Token Microservice
nfaccesstoken:
  global:
    #  For Ephemeral Storage (Values specified are in MB)
    logStorage: 70
    crictlStorage: 1
    ephemeralStorageLimit: 1024

  # Flag to disable Oauth micro-service
  enabled: true
  # Image Details
  image:
    name: ocnrf-nfaccesstoken
    tag: 22.1.0
    pullPolicy: IfNotPresent

  # Access token key certificate infrastructure details
  oauth:
    # Issuer OCNRF's NF Instance ID is a Mandatory parameter if
    # Access Token Service is deployed (i.e. nfaccesstoken.enabled= true)
    #
    # This is NRF Instance ID that will be used for signing AccessTokenClaim (iss IE of AccessTokenClaim).
    #
    # If NRF needs to issue AccessTokenClaim using it's own NF instance ID then
    # the nrfInstanceId configured in the global section (global.nrfInstanceId) needs to configured here again.
    #
    # If NRF needs to issue AccessTokenClaim using a common/virtual then
    # a common/virtual NF instance ID needs to be configured here (along with the
    # common/virtual PrivateKey and Certificate Pair). The same NF instance id
    # and PrivateKey and Certificate Pair needs to be configured in all other NRFs
    # as well so that tokens issues by all the NRF can be validated using a Single
    # NfIstanceId and KeyPair.
    nrfInstanceId: *nrfInstanceId

  # Resource details
  resources:
    limits:
      #@min_resources- cpu: 1
      cpu: 4
      #@min_resources- memory: 1Gi
      memory: 2Gi
    requests:
      #@min_resources- cpu: 1
      cpu: 4
      #@min_resources- memory: 1Gi
      memory: 2Gi
    target:
      averageCpuUtil: 80

  hookRestartPolicy: Never
  #@Engineering-start
  # Engineering Configuration:
  podRestartPolicy: Always
  #@Engineering-end

  readinessProbe:
    # tells the kubelet that it should wait xx second before performing the first probe
    initialDelaySeconds: 25
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 10
    # Number of seconds after which the probe times out
    timeoutSeconds: 3
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 3
  livenessProbe:
    # tells the kubelet that it should wait xx second before performing the first probe
    initialDelaySeconds: 25
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 10
    # Number of seconds after which the probe times out
    timeoutSeconds: 5
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 5

  #@Engineering-start
  # Engineering Configuration:
  server:
    waitTime: 35

  #@Engineering-end

  # Min replicas to scale to maintain an average CPU utilization
  #@min_resources- minReplicas: 1
  minReplicas: 1
  # Max replicas to scale to maintain an average CPU utilization
  maxReplicas: 1

  service:
    # Service Type
    type: ClusterIP

    #Labels and Annotations that are specific to service nfAccesstoken are added here.
    customExtension:
      labels: {}
      annotations: {}

  #Labels and Annotations that are specific to deployment nfAccesstoken are added here.
  deployment:
    customExtension:
      labels: {}
      annotations: {}

  #@Engineering-start
  # Engineering Configuration: The time interval between 2 consecutive system options fetch from DB in Milliseconds
  systemOptionsFetchInterval: 3000
  #@Engineering-end

  #@Engineering-start
  # Engineering Configuration: setting hikari pool size
  # and Idle Timeout for DB Connections
  hikariPoolSize: 30
  hikariConnectionTimeout: 60000
  # hikariMinimumIdle should be less than maximum pool size
  hikariMinimumIdle: 10
  hikariIdleTimeout: 500000

  undertow:
    maxConcurrentStream: 100
    initialWindowSize: 65535
    noRequestTimeout: 60
    ioThreads: 8
    workerThreads: 64
  #@Engineering-end

  # Allowed Values: DISABLED, ENABLED, USE_GLOBAL_VALUE
  extraContainers: USE_GLOBAL_VALUE

#########################################################
#            Section End  : nfaccesstoken attributes    #
#########################################################

#########################################################
#            Section Start: nrfconfiguration attributes #
#########################################################
nrfconfiguration:
  global:
    #  For Ephemeral Storage (Values specified are in MB)
    logStorage: 70
    crictlStorage: 1
    ephemeralStorageLimit: 1024

  #@Engineering-start
  enabled: true
  #@Engineering-end
  image:
    # image name
    name: ocnrf-nrfconfiguration
    # tag name of image
    tag: 22.1.0
    # Pull Policy - Possible Values are:- Always, IfNotPresent, Never
    pullPolicy: IfNotPresent

  oauth:
    nrfInstanceId: *nrfInstanceId

  service:
    # If Static load balancer IP needs to be set, then set staticIpAddressEnabled flag to true and provide value for staticIpAddress
    # Else random IP will be assigned by the External LoadBalancer from its IP Pool
    staticIpAddressEnabled: false
    staticIpAddress: 10.75.212.50

    # If Static node port needs to be set, then set staticNodePortEnabled flag to true and provide value for staticNodePort
    # Else random node port will be assigned by K8
    staticNodePortEnabled: false
    staticNodePort: 30076

    # Service Type
    type: LoadBalancer

    #Labels and Annotations that are specific to service nrfConfiguration are added here.
    customExtension:
      labels: {}
      annotations:
        oracle.com.cnc/app-protocols: '{"http2-oam":"HTTP2"}'

  #Labels and Annotations that are specific to deployment nrfConfiguration are added here.
  deployment:
    customExtension:
      labels: {}
      annotations: {}

  # Resource details
  resources:
    limits:
      #@min_resources- cpu: 1
      cpu: 2
      #@min_resources- memory: 1Gi
      memory: 2Gi
    requests:
      #@min_resources- cpu: 1
      cpu: 2
      #@min_resources- memory: 1Gi
      memory: 2Gi
    target:
      averageCpuUtil: 80


  hookRestartPolicy: Never
  #@Engineering-start
  # Engineering Configuration:
  podRestartPolicy: Always
  #@Engineering-end

  livenessProbe:
    # tells the kubelet that it should wait xx second before performing the first probe
    initialDelaySeconds: 20
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 10
    # Number of seconds after which the probe times out
    timeoutSeconds: 5
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 5
  readinessProbe:
    # tells the kubelet that it should wait second before performing the first probe
    initialDelaySeconds: 35
    # Number of seconds after which the probe times out
    timeoutSeconds: 3
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 10
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 3

  #@Engineering-start
  # Engineering Configuration:
  server:
    # The maximum number of connections that the server will accept and process at any given time
    maxConnections: 10000
    # The maximum queue length for incoming connection requests
    queueSize: 100
    # maximum number of simultaneous requests that can be handled
    maxThreads: 200
    # The minimum number of threads always kept running
    spareThreads: 20

  #@Engineering-end

  #@Engineering-start
  # Engineering Configuration:: setting hikari pool size
  # and Idle Timeout for DB Connections
  hikariPoolSize: 10
  hikariConnectionTimeout: 60000
  # hikariMinimumIdle should be less than maximum pool size
  hikariMinimumIdle: 5
  hikariIdleTimeout: 500000
  #@Engineering-end

  # Allowed Values: DISABLED, ENABLED, USE_GLOBAL_VALUE
  extraContainers: USE_GLOBAL_VALUE

#########################################################
#            Section End  : nrfconfiguration attributes #
#########################################################

#########################################################
#            Section Start: nrfartisan attributes   #
#########################################################
# NRF microservices
nrfartisan:
  global:
    #  For Ephemeral Storage (Values specified are in MB)
    logStorage: 70
    crictlStorage: 1
    ephemeralStorageLimit: 1024


  image:
    # image name
    name: ocnrf-nrfartisan
    # tag name of image
    tag: 22.1.0
    # Pull Policy - Possible Values are:- Always, IfNotPresent, Never
    pullPolicy: IfNotPresent

  # Resource details
  resources:
    limits:
      #@min_resources- cpu: 1
      cpu: 4
      #@min_resources- memory: 1Gi
      memory: 2Gi
    requests:
      #@min_resources- cpu: 1
      cpu: 4
      #@min_resources- memory: 1Gi
      memory: 2Gi
    target:
      averageCpuUtil: 80

  # Min replicas to scale to maintain an average CPU utilization
  #@min_resources- minReplicas: 1
  minReplicas: 1
  # Max replicas to scale to maintain an average CPU utilization
  maxReplicas: 1

  hookRestartPolicy: Never
  #@Engineering-start
  # Engineering Configuration:
  podRestartPolicy: Always
  #@Engineering-end

  #@Engineering-start
  # Engineering Configuration:

  # jaeger details
  jaeger:
    service:
      name: "occne-tracer-jaeger-collector.occne-infra"
      port: 9411
    #@Engineering-end



  readinessProbe:
    # tells the kubelet that it should wait xx second before performing the first probe
    initialDelaySeconds: 20
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 10
    # Number of seconds after which the probe times out
    timeoutSeconds: 3
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 3
  livenessProbe:
    # tells the kubelet that it should wait xx second before performing the first probe
    initialDelaySeconds: 20
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 10
    # Number of seconds after which the probe times out
    timeoutSeconds: 5
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 5

  #@Engineering-start
  # Engineering Configuration:
  server:
    # The maximum number of connections that the server will accept and process at any given time
    maxConnections: 10000
    # The maximum queue length for incoming connection requests
    queueSize: 100
    # maximum number of simultaneous requests that can be handled
    maxThreads: 200
    # The minimum number of threads always kept running
    spareThreads: 20
    # waiting time
    waitTime: 35


  # Engineering Configuration: The time interval between 2 consecutive system options fetch from DB in Milliseconds
  systemOptionsFetchInterval: 3000

  # Engineering Configuration: The time interval between 2 consecutive re-population of slfDiscoveredCandidateList in Milliseconds
  slfDiscoveredCandidateListFetchInterval: 10000

  # enable/ disable server compression gzip
  responseCompressionGzip: true
  #@Engineering-end


  service:
    # Service Type
    type: ClusterIP

    # Labels and Annotations that are specific to service nrfArtisan are added here.
    customExtension:
      labels: {}
      annotations: {}

  # Labels and Annotations that are specific to deployment nrfArtisan are added here.
  deployment:
    customExtension:
      labels: {}
      annotations: {}


  #@Engineering-start
  # Engineering Configuration: setting hikari pool size
  # and Idle Timeout for DB Connections
  hikariPoolSize: 30
  hikariConnectionTimeout: 60000
  # hikariMinimumIdle should be less than maximum pool size
  hikariMinimumIdle: 10
  hikariIdleTimeout: 500000

    #@Engineering-end

  # Allowed Values: DISABLED, ENABLED, USE_GLOBAL_VALUE
  extraContainers: USE_GLOBAL_VALUE

#########################################################
#            Section End  : nrfartisan attributes   #
#########################################################



#@Engineering-start
#########################################################
#            Section Start: nrfclient  attributes       #
#########################################################
# Engineering Configuration: nrfclient  attributes
nrfclient:
  global:
    #  For Ephemeral Storage (Values specified are in MB)
    logStorage: 70
    crictlStorage: 1
    ephemeralStorageLimit: 1024

  # Global control if NRF Client with all dependent services is not needed in deployment
  enabled: false
  nrf-client:
    # Microservice level control if specific microservice need to be disabled
    enabled: false
    # Deployment specific configuration
    deploymentNrfClientService:
      # Docker registry for NRF Client Microservice
      dockerRegistry: ocnrf-registry.us.oracle.com:5000
      # NRF Client Microservice image name
      image: nrf-client/nrf-client
      # NRF Client Microservice tag
      imageTag: '1.0.0'
      # Pull Policy - Possible Values are:- Always, IfNotPresent, Never
      pullPolicy: IfNotPresent
      # Replicas for NRF-Client - This is exact value without scaling
      replicas: 1
      envJaegerSamplerParam: '1'
      envJaegerSamplerType: ratelimiting
      envJaegerServiceName: ocnrf-clientservice
      # NF Namespace in which NRF-Client is deployed. For now it is kept like this, we may omit it and make it automated
      envNfNamespace: 'ocnrf'
      # NF type of user of this microservice
      envNfType: 'nrf'
      # Details of microservices with service name which need to be monitored by App-Info microservice
      envConsumeSvcName: 'ocnrf-nfregistration:nnrf-nfm,ocnrf-nfsubscription:nnrf-nfm,ocnrf-nfdiscovery:nnrf-disc'
      nodeSelectorEnabled: false
      nodeSelectorKey: zone
      nodeSelectorValue: app
      # Resource Details
      cpuRequest: 1
      cpuLimit: 1
      memoryRequest: 1Gi
      memoryLimit: 1Gi
    # This config map is for providing inputs to NRF-Client
    configmapApplicationConfig:
      # NF Profile. Please keep mind the formatting
      # nrfApiRoot :-
      # nrfClientType :-
      # nrfClientSubscribeTypes:-
      # enableF3:- Enable 29510 specification version 15.3 flag
      # Network function profile. Note:- In NF Profile below, NFInstanceId is just a placeholder. NFInstanceId will be generated by NRF-Client and re-use it as needed.
      profile: |-
        [appcfg]
        nrfApiRoot=http://ocnrf-ingressgateway.ocnrf
        nrfClientType=NRF
        nrfClientSubscribeTypes=PCF,UDM
        enableF3=true
        appProfiles=[{"nfInstanceId":"76260676-1db1-45b1-b88e-5e2b28762e1f","nfType":"NRF","nfStatus":"REGISTERED","plmnList":null,"nsiList":null,"fqdn":"nrf.oracle.com","interPlmnFqdn":null,"ipv4Addresses":null,"ipv6Addresses":null,"priority":null,"capacity":null,"load":null,"locality":null,"udrInfo":null,"udmInfo":null,"ausfInfo":null,"amfInfo":null,"smfInfo":null,"upfInfo":null,"pcfInfo":null,"bsfInfo":null,"customInfo":null,"recoveryTime":null,"nfServices":[{"serviceInstanceId":"03063893-cf9e-4f7a-9827-067f6fa9dd01","serviceName":"nnrf-nfm","versions":[{"apiVersionInUri":"v1","apiFullVersion":"1.2.2","expiry":"2019-08-03T18:55:08.871+0000"}],"scheme":"http","nfServiceStatus":"REGISTERED","fqdn":"nrf.oracle.com","interPlmnFqdn":null,"apiPrefix":"bsf-service","defaultNotificationSubscriptions":null,"allowedPlmns":null,"allowedNfTypes":["PCF","NEF"],"allowedNfDomains":null,"allowedNssais":null,"priority":null,"capacity":null,"load":null,"recoveryTime":null,"supportedFeatures":null}],"sNssais":null}]

    serviceNrfClientService:
      type: NodePort

  config-server:
    # Microservice level flag to enable/disable
    enabled: true
    deploymentConfigServer:
      # config-server image name. Please note registry is taken from global section above
      image: nrf-client/ocpm_config_server
      # config-server image tag
      imageTag: staging-336524
      # Pull Policy - Possible Values are:- Always, IfNotPresent, Never
      pullPolicy: IfNotPresent
      # Jaeger Service Name
      envJaegerServiceName: pcf-config
      # Mysql Database name for Config Server
      envMysqlDatabase: ocpm_config_server
      # Replicas for Config server - This is exact value without scaling
      replicas: 1
      nodeSelectorEnabled: false
      nodeSelectorKey: zone
      nodeSelectorValue: app
      # Resource Details
      cpuRequest: 2
      cpuLimit: 8
      memoryRequest: 2Gi
      memoryLimit: 2Gi
    servicePcfConfig:
      type: NodePort

  # Details of appinfo microservices
  appinfo:
    appinfo:
      # appinfo  image details with registry
      image: ocnrf-registry.us.oracle.com:5000/nrf-client/app_info
      # Image tag
      imageTag: latest
      # Replicas for App Info - This is exact value without scaling
      replicas: 1
      # debugging
      debug: true
      # Pull Policy - Possible Values are:- Always, IfNotPresent, Never
      pullPolicy: IfNotPresent
      # Resource Details
      cpuRequest: 200m
      cpuLimit: 200m
      memoryRequest: 1Gi
      memoryLimit: 1Gi

  # Details of perf-info microservices
  perf-info:
    # Service namespace for perf-info
    service_namespace: ocnrf
    # Replicas for perf Info - This is exact value without scaling
    replicaCount: 1
    image:
      # perf_info image details with registry
      repository: ocnrf-registry.us.oracle.com:5000/nrf-client/perf_info
      # Image tag
      tag: staging-336524
      # Pull Policy - Possible Values are:- Always, IfNotPresent, Never
      pullPolicy: IfNotPresent
    service:
      # Specify type of service - Possible values are :- ClusterIP, NodePort, LoadBalancer and ExternalName
      type: NodePort
      # Specify port for service
      port: 5905
    # Resource Details
    resources:
      limits:
        cpu: 200m
        memory: 1Gi
      requests:
        cpu: 200m
        memory: 1Gi
    nodeSelector: {}
    tolerations: []
    affinity: {}
    ingress:
      enabled: false


  # Allowed Values: DISABLED, ENABLED, USE_GLOBAL_VALUE
  extraContainers: USE_GLOBAL_VALUE


#########################################################
#            Section End  : nrfclient  attributes       #
#########################################################
#@Engineering-end

#########################################################
#            Section Start  : appinfo attributes    #
#########################################################
appinfo:
  global:
    #  For Ephemeral Storage (Values specified are in MB)
    logStorage: 70
    crictlStorage: 1

  #@Engineering-start
  # Flag to app info service
  enabled: true
  #@Engineering-end
  # Image Details
  image: oc-app-info
  imageTag: 22.1.0
  pullPolicy: IfNotPresent

  #@Engineering-start
  # Engineering Configuration:
  #Config client configuration
  commonCfgClient:
    enabled: true
  commonCfgServer:
    configServerSvcName: nrfconfiguration
    port: *configurationServicePort
    pollingInterval: 5000
    connectionTimeout: 10000
  commonServiceName: *appinfoCommonSvcName
  #@Engineering-end

  # Db Hook Image details
  dbHookImage:
    name: common_config_hook
    tag: 22.1.2
    pullPolicy: IfNotPresent

  # Db Hook Configuration
  # Engineering configuration to select database (read only)
  dbConfig:
    dbHost: *mySqlHostRef
    dbPort: *mySqlPortRef
    secretName: *privilegedSecretNameRef
    dbName: *dbNameRef
    dbEngine: *databaseEngine
    #@Engineering-start
    # Engineering Configuration:
    # Name of the Key configured for "DB Username" in Secret with following name: "<dbConfig.secretName>"
    dbUNameLiteral: *dbUserRef
    # Name of the Key configured for "DB Password" in Secret with following name: "<dbConfig.secretName>"
    dbPwdLiteral: *dbPwdRef
  #@Engineering-end



  # Resource details
  resources:
    limits:
      #@min_resources- cpu: 200m
      cpu: 1
      #@min_resources- memory: 1Gi
      memory: 1Gi
      ephemeralStorage: 1024Mi
    requests:
      #@min_resources- cpu: 200m
      cpu: 1
      #@min_resources- memory: 1Gi
      memory: 1Gi

  service:
    type: ClusterIP

    #Labels and Annotations that are specific to service appinfo are added here.
    customExtension:
      labels: {}
      annotations: {}

  #Labels and Annotations that are specific to deployment appinfo are added here.
  deployment:
    customExtension:
      labels: {}
      annotations: {}

  #@Engineering-start
  # Engineering Configuration:
  replicas: 1
  debug: false
  # Flag to enable replication status check
  replicationStatusCheck: false
  infraServices: []
  core_services: []
  fullnameOverride: ''
  #@Engineering-end

  # Allowed Values: DISABLED, ENABLED, USE_GLOBAL_VALUE
  extraContainers: USE_GLOBAL_VALUE

  #########################################################
  #            Section End  : appinfo attributes    #
  #########################################################

  #########################################################
  #            Section Start  : alternate-route attributes    #
  #########################################################

  # Default values for alternate-route.
  # This is a YAML-formatted file.
  # Declare variables to be passed into your templates.

alternate-route:
  global:
    #For Ephemeral Storage (Values specified are in MB)
    logStorage: 70
    crictlStorage: 1

    ## Engineering configuration for Config Client (read only)
    appinfoServiceEnable: true

    ## Engineering configuration for Config Client (read only)
    nodeSelector:
      nodeKey: ''
      nodeValue: ''

  # Use 'extraContainers' attribute to control the usage of extra container(DEBUG tool).
  # Allowed Values: DISABLED, ENABLED, USE_GLOBAL_VALUE
  # If assigned with ENABLED or USE_GLOBAL_VALUE, then ensure "extraContainersTpl" Yaml chunk is defined
  # at Service level or Global level in the parent chart based on the value assigned respectivley.
  extraContainers: USE_GLOBAL_VALUE

  deploymentDnsSrv:
    image: alternate_route
    tag: 22.1.2
    pullPolicy: IfNotPresent

  # Specify type of service - Possible values are :- ClusterIP, NodePort, LoadBalancer and ExternalName
  service:
    type: ClusterIP

  dbHookImage:
    name: common_config_hook
    tag: 22.1.2
    pullPolicy: IfNotPresent

  # Number of Pods must always be available, even during a disruption.
  minAvailable: 2
  # Min replicas to scale to maintain an average CPU utilization
  minReplicas: 1
  # Max replicas to scale to maintain an average CPU utilization
  maxReplicas: 1

  startupProbe:
    # tells the kubelet that it should wait second before performing the first probe
    initialDelaySeconds: 30
    # Number of seconds after which the probe times out
    timeoutSeconds: 3
    # specifies that the kubelet should perform a readiness probe every xx seconds
    periodSeconds: 10
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 3

  readinessProbe:
    # tells the kubelet that it should wait second before performing the first probe
    initialDelaySeconds: 30
    # Number of seconds after which the probe times out
    timeoutSeconds: 3
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 10
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 3

  livenessProbe:
    # tells the kubelet that it should wait second before performing the first probe
    initialDelaySeconds: 30
    # Number of seconds after which the probe times out
    timeoutSeconds: 3
    # specifies that the kubelet should perform a liveness probe every xx seconds
    periodSeconds: 15
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 3

  # Resource details
  resources:
    limits:
      cpu: 2
      commonHooksCpu: 1
      memory: 4Gi
      commonHooksMemory: 1Gi
    requests:
      cpu: 1
      commonHooksCpu: 1
      memory: 2Gi
      commonHooksMemory: 1Gi
    target:
      averageCpuUtil: 65

  #@Engineering-start
  # Engineering configuration for Config Client (read only)
  # Engineering Configuration:
  # Config client configuration 
  commonCfgClient:
    enabled: true
  commonCfgServer:
    # If below parameter is present then it will be used for integrating with config-server.
    # This parameter will be appended with the current release name when deployed with alternate-route
    # In case host name is expected, then leave this parameter blank
    configServerSvcName: nrfconfiguration
    port: *configurationServicePort
    pollingInterval: 5000 #(in ms)
    connectionTimeout: 10000 #(in ms)
  commonServiceName: *altRouteCommonSvcName
  #@Engineering-end

  # Engineering configuration to select database (read only)
  dbConfig:
    dbHost: *mySqlHostRef
    dbPort: *mySqlPortRef
    secretName: *privilegedSecretNameRef
    dbName: *dbNameRef
    dbEngine: *databaseEngine
    
    #@Engineering-start
    # Engineering Configuration:
    # Name of the Key configured for "DB Username" in Secret with following name: "<dbConfig.secretName>"
    dbUNameLiteral: dbUsername
    # Name of the Key configured for "DB Password" in Secret with following name: "<dbConfig.secretName>"
    dbPwdLiteral: dbPassword
    #@Engineering-end
    
  #Static virtual FQDN Config
  staticVirtualFqdns:
    - name: http://abc.test.com
      alternateFqdns:
      - target: abc.test.com
        port: 5060
        priority: 10
      - target: xyz.test.com
        port: 5060
        priority: 2

  dnsSrvEnabled: true
  dnsSrvFqdnSetting:
    enabled : false
    pattern : "_{scheme}._tcp.{fqdn}."
  #########################################################
  #            Section End  : alternate-route attributes    #
  #########################################################

